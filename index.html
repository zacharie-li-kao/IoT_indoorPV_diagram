<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indoor PV and IoT Device Matcher</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1a2332 0%, #0f1923 100%);
            color: #E8F1F8;
            padding: 20px;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #1e3a5f 0%, #2c5282 100%);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .header h1 {
            font-size: 28px;
            color: #60a5fa;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 14px;
            color: #94a3b8;
        }

        .container {
            display: grid;
            grid-template-columns: 350px 1fr 350px;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }

        .column {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: linear-gradient(135deg, #1e3a5f 0%, #152844 100%);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            border: 1px solid #2c5282;
        }

        h2 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #60a5fa;
            border-bottom: 2px solid #2c5282;
            padding-bottom: 8px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            margin-top: 10px;
            font-size: 13px;
            color: #cbd5e1;
        }

        label:first-of-type {
            margin-top: 0;
        }

        input[type="text"],
        input[type="number"],
        input[type="file"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 5px;
            background-color: #0f1923;
            border: 1px solid #2c5282;
            border-radius: 6px;
            color: #E8F1F8;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        input[type="number"]:focus {
            outline: none;
            border-color: #60a5fa;
        }

        button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            color: #FFFFFF;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.3);
        }

        button:hover {
            background: linear-gradient(135deg, #1d4ed8 0%, #1e40af 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .listbox {
            background-color: #0f1923;
            border: 1px solid #2c5282;
            border-radius: 6px;
            height: 180px;
            overflow-y: auto;
            padding: 5px;
            margin-top: 10px;
        }

        .listbox-item {
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 3px;
            transition: background-color 0.2s;
            color: #cbd5e1;
        }

        .listbox-item:hover {
            background-color: #1e3a5f;
        }

        .listbox-item.selected {
            background-color: #2563eb;
            color: #fff;
        }

        .chart-container {
            background: linear-gradient(135deg, #1e3a5f 0%, #152844 100%);
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            border: 1px solid #2c5282;
            height: fit-content;
        }

        canvas {
            max-width: 100%;
            background-color: #f8fafc;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 12px 0;
            padding: 8px;
            background-color: #0f1923;
            border-radius: 6px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #2563eb;
        }

        .checkbox-container label {
            margin: 0;
            cursor: pointer;
        }

        .slider-container {
            margin: 15px 0;
            padding: 12px;
            background-color: #0f1923;
            border-radius: 6px;
            border: 2px solid transparent;
            transition: border-color 0.3s;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .slider-label span:first-child {
            color: #cbd5e1;
        }

        .slider-label span:last-child {
            color: #60a5fa;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #2c5282;
            outline: none;
            border-radius: 3px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #2563eb;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 2px 6px rgba(37, 99, 235, 0.4);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #2563eb;
            cursor: pointer;
            border-radius: 50%;
            border: none;
            box-shadow: 0 2px 6px rgba(37, 99, 235, 0.4);
        }

        .slider-section {
            max-height: 350px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .slider-section::-webkit-scrollbar,
        .listbox::-webkit-scrollbar {
            width: 8px;
        }

        .slider-section::-webkit-scrollbar-track,
        .listbox::-webkit-scrollbar-track {
            background: #0f1923;
            border-radius: 4px;
        }

        .slider-section::-webkit-scrollbar-thumb,
        .listbox::-webkit-scrollbar-thumb {
            background: #2c5282;
            border-radius: 4px;
        }

        .slider-section::-webkit-scrollbar-thumb:hover,
        .listbox::-webkit-scrollbar-thumb:hover {
            background: #3b82f6;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        @media (max-width: 1400px) {
            .container {
                grid-template-columns: 1fr;
            }
        }

        .sufficiency-item {
            background-color: #0f1923;
            padding: 12px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 4px solid #2563eb;
        }

        .sufficiency-item.excellent {
            border-left-color: #10b981;
        }

        .sufficiency-item.good {
            border-left-color: #f59e0b;
        }

        .sufficiency-item.poor {
            border-left-color: #ef4444;
        }

        .coverage-bar {
            height: 8px;
            background-color: #1e3a5f;
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }

        .coverage-fill {
            height: 100%;
            transition: width 0.5s ease;
        }

        .coverage-fill.excellent {
            background: linear-gradient(90deg, #10b981 0%, #34d399 100%);
        }

        .coverage-fill.good {
            background: linear-gradient(90deg, #f59e0b 0%, #fbbf24 100%);
        }

        .coverage-fill.poor {
            background: linear-gradient(90deg, #ef4444 0%, #f87171 100%);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Indoor PV and IoT Device Matcher</h1>
        <p>Analyze and compare indoor photovoltaic systems with IoT device requirements</p>
    </div>

    <div class="container">
        <!-- Left Column -->
        <div class="column">
            <div class="panel">
                <h2>üìÅ Load PV Data</h2>
                <input type="file" id="pvFileInput" multiple accept=".txt">
                <button onclick="loadPVData()">Add PV Data</button>
            </div>

            <div class="panel">
                <h2>üì± Add IoT Device</h2>
                <label>Device Name:</label>
                <input type="text" id="iotName" placeholder="e.g., Temperature Sensor">
                
                <label>Peak Power Consumption (mW):</label>
                <input type="number" id="iotPeakPower" step="0.01" placeholder="e.g., 100">
                
                <label>Surface Area (cm¬≤):</label>
                <input type="number" id="iotSurfaceArea" step="0.01" placeholder="e.g., 25">
                
                <button onclick="addIoTDevice()">Add IoT Device to Graph</button>
            </div>

            <div class="panel">
                <h2>üóëÔ∏è Remove Curves</h2>
                <div class="listbox" id="curveListbox"></div>
                <button onclick="removeSelected()">Remove Selected</button>
            </div>

            <div class="panel">
                <h2>üí° Illumination Range</h2>
                <label>Lowest Illumination (mW/cm¬≤):</label>
                <input type="number" id="lowIllumination" step="0.01" placeholder="e.g., 0.1">
                
                <label>Highest Illumination (mW/cm¬≤):</label>
                <input type="number" id="highIllumination" step="0.01" placeholder="e.g., 5.0">
                
                <button onclick="updatePlot()">Update Illumination Range</button>
                <button onclick="checkSufficiency()">üîç Check PV-IoT Sufficiency</button>
            </div>
            
            <div class="panel" id="sufficiencyResults" style="display: none;">
                <h2>‚úÖ Sufficiency Analysis Results</h2>
                <div id="sufficiencyContent" style="font-size: 13px; line-height: 1.6;"></div>
            </div>
        </div>

        <!-- Center Column -->
        <div class="column">
            <div class="chart-container">
                <canvas id="chart"></canvas>
            </div>
            
            <div class="panel">
                <h2>üìã PV Data File Format Instructions</h2>
                <div style="background-color: #0f1923; padding: 15px; border-radius: 6px; font-size: 13px; line-height: 1.8;">
                    <p style="margin-bottom: 12px; color: #60a5fa; font-weight: 600;">File Format Requirements:</p>
                    <ul style="margin-left: 20px; color: #cbd5e1;">
                        <li>File extension: <code style="background-color: #1e3a5f; padding: 2px 6px; border-radius: 3px; color: #93c5fd;">.txt</code></li>
                        <li>Format: Two-column space-separated or tab-separated values</li>
                        <li>No header row required</li>
                    </ul>
                    
                    <p style="margin: 12px 0; color: #60a5fa; font-weight: 600;">Column Layout:</p>
                    <ul style="margin-left: 20px; color: #cbd5e1;">
                        <li><strong>Column 1:</strong> Incident Power Density (mW/cm¬≤)</li>
                        <li><strong>Column 2:</strong> Efficiency (%)</li>
                    </ul>
                    
                    <p style="margin: 12px 0; color: #60a5fa; font-weight: 600;">Example File Content:</p>
                    <pre style="background-color: #1a2332; padding: 10px; border-radius: 4px; overflow-x: auto; color: #93c5fd; font-family: monospace; font-size: 12px;">0.1    5.2
0.5    8.7
1.0    12.3
2.5    15.8
5.0    18.1
10.0   19.5</pre>
                    
                    <p style="margin-top: 12px; color: #94a3b8; font-style: italic; font-size: 12px;">
                        üí° <strong>Note:</strong> The power generation density will be automatically calculated as: 
                        <span style="color: #60a5fa;">Incident Power √ó Efficiency / 100</span>
                    </p>
                </div>
            </div>
        </div>

        <!-- Right Column -->
        <div class="column">
            <div class="panel">
                <h2>‚öôÔ∏è Display Options</h2>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="showDetailedBalance" onchange="updatePlot()">
                    <label for="showDetailedBalance">Show Detailed Balance Limit</label>
                </div>
                
                <div class="checkbox-container">
                    <input type="checkbox" id="logScale" onchange="updatePlot()">
                    <label for="logScale">Logarithmic Y-Axis Scale</label>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Power Loss Factor (%)</span>
                        <span id="lossFactorValue">0</span>
                    </div>
                    <input type="range" id="lossFactor" min="0" max="50" value="0" step="1" oninput="updateLossFactor(this.value)">
                </div>
            </div>

            <div class="panel">
                <h2>üéöÔ∏è IoT Device Scaling</h2>
                <div class="slider-section" id="iotSliders">
                    <p style="color: #94a3b8; font-size: 13px; text-align: center; padding: 20px;">No IoT devices added yet</p>
                </div>
            </div>

            <div class="panel">
                <h2>üíæ Export & Reports</h2>
                <div class="button-group">
                    <button onclick="exportGraph()">üìä Export Graph (PNG)</button>
                    <button onclick="exportData()">üìÑ Export Data (TXT)</button>
                    <button onclick="generateReport()">üìë Generate PDF Report</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Data storage
        let pvData = {};
        let iotDevices = {};
        let originalPCD = {};
        let colors = {};
        let iotColors = {};
        let selectedCurves = new Set();
        let chart = null;
        let lossFactor = 0;

        // Detailed balance data
        const detailedBalanceData = {
            x: [6.73, 3.365, 0.673, 0.3365, 0.0673, 0.03365],
            y: [3.520463, 1.7353305, 0.3357597, 0.1654907, 0.03199442, 0.015758295]
        };

        // Initialize chart
        function initChart() {
            const ctx = document.getElementById('chart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1.5,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Incident Power Density (mW/cm¬≤)',
                                color: '#1e293b',
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: { color: '#1e293b' },
                            grid: { color: '#e2e8f0' }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Power Generation Density (mW/cm¬≤)',
                                color: '#1e293b',
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: { color: '#1e293b' },
                            grid: { color: '#e2e8f0' }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: { 
                                color: '#1e293b',
                                font: { size: 12 }
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        },
                        annotation: {
                            annotations: {}
                        }
                    }
                }
            });
        }

        // Load PV data from files
        async function loadPVData() {
            const fileInput = document.getElementById('pvFileInput');
            const files = fileInput.files;

            if (files.length === 0) {
                alert('Please select at least one file');
                return;
            }

            for (let file of files) {
                const text = await file.text();
                const name = file.name.replace('.txt', '');
                const lines = text.trim().split('\n');
                const data = lines.map(line => {
                    const parts = line.trim().split(/\s+/);
                    return [parseFloat(parts[0]), parseFloat(parts[1])];
                });

                pvData[name] = data;
                generateColor(name);
            }

            updateCurveListbox();
            updatePlot();
        }

        // Generate color for PV device
        function generateColor(name) {
            const keys = Object.keys(pvData);
            const index = keys.indexOf(name);
            const hue = index / keys.length;
            colors[name] = hsvToRgb(hue, 0.8, 0.8);
        }

        // Generate color for IoT device
        function generateIoTColor(name) {
            const hue = Math.random();
            const saturation = 0.7 + 0.3 * Math.random();
            const value = 0.5 + 0.5 * Math.random();
            iotColors[name] = hsvToRgb(hue, saturation, value);
        }

        // HSV to RGB conversion
        function hsvToRgb(h, s, v) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);

            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }

            return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
        }

        // Add IoT device
        function addIoTDevice() {
            const name = document.getElementById('iotName').value.trim();
            const peakPower = parseFloat(document.getElementById('iotPeakPower').value);
            const surfaceArea = parseFloat(document.getElementById('iotSurfaceArea').value);

            if (!name) {
                alert('Please enter a device name');
                return;
            }
            if (!peakPower || peakPower <= 0) {
                alert('Please enter a valid peak power consumption');
                return;
            }
            if (!surfaceArea || surfaceArea <= 0) {
                alert('Please enter a valid surface area');
                return;
            }

            const pcd = peakPower / surfaceArea;
            iotDevices[name] = { pcd, peakPower, surfaceArea, scaleFactor: 1.0 };
            originalPCD[name] = pcd;
            generateIoTColor(name);
            addIoTSlider(name);
            updateCurveListbox();
            updatePlot();

            document.getElementById('iotName').value = '';
            document.getElementById('iotPeakPower').value = '';
            document.getElementById('iotSurfaceArea').value = '';
        }

        // Add slider for IoT device
        function addIoTSlider(name) {
            const container = document.getElementById('iotSliders');
            
            // Remove placeholder if it exists
            if (container.querySelector('p')) {
                container.innerHTML = '';
            }
            
            const sliderDiv = document.createElement('div');
            sliderDiv.className = 'slider-container';
            sliderDiv.id = `slider-${name}`;
            sliderDiv.style.marginTop = '0';
            sliderDiv.innerHTML = `
                <div class="slider-label">
                    <span>${name}</span>
                    <span id="value-${name}">1.00x</span>
                </div>
                <input type="range" min="0.1" max="10" value="1" step="0.01" 
                       oninput="updateIoTScale('${name}', this.value)">
            `;
            container.appendChild(sliderDiv);
        }

        // Update IoT device scale
        function updateIoTScale(name, value) {
            const scaleFactor = parseFloat(value);
            iotDevices[name].scaleFactor = scaleFactor;
            iotDevices[name].pcd = originalPCD[name] * scaleFactor;
            document.getElementById(`value-${name}`).textContent = scaleFactor.toFixed(2) + 'x';
            updatePlot();
        }

        // Update loss factor
        function updateLossFactor(value) {
            lossFactor = parseFloat(value);
            document.getElementById('lossFactorValue').textContent = value;
            updatePlot();
        }

        // Update curve listbox
        function updateCurveListbox() {
            const listbox = document.getElementById('curveListbox');
            listbox.innerHTML = '';

            const allItems = [...Object.keys(pvData), ...Object.keys(iotDevices)];
            
            if (allItems.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.style.padding = '20px';
                emptyMsg.style.textAlign = 'center';
                emptyMsg.style.color = '#94a3b8';
                emptyMsg.style.fontSize = '13px';
                emptyMsg.textContent = 'No curves added yet';
                listbox.appendChild(emptyMsg);
                return;
            }

            allItems.forEach(name => {
                const item = document.createElement('div');
                item.className = 'listbox-item';
                const type = pvData[name] ? 'üìà PV' : 'üì± IoT';
                item.textContent = `${type}: ${name}`;
                item.onclick = () => toggleSelection(item, name);
                if (selectedCurves.has(name)) {
                    item.classList.add('selected');
                }
                listbox.appendChild(item);
            });
        }

        // Toggle selection
        function toggleSelection(element, name) {
            if (selectedCurves.has(name)) {
                selectedCurves.delete(name);
                element.classList.remove('selected');
            } else {
                selectedCurves.add(name);
                element.classList.add('selected');
            }
        }

        // Remove selected curves
        function removeSelected() {
            if (selectedCurves.size === 0) {
                alert('Please select curves to remove');
                return;
            }

            selectedCurves.forEach(name => {
                if (pvData[name]) {
                    delete pvData[name];
                    delete colors[name];
                }
                if (iotDevices[name]) {
                    delete iotDevices[name];
                    delete iotColors[name];
                    delete originalPCD[name];
                    const sliderDiv = document.getElementById(`slider-${name}`);
                    if (sliderDiv) sliderDiv.remove();
                }
            });

            // Show placeholder if no IoT devices remain
            const sliderContainer = document.getElementById('iotSliders');
            if (Object.keys(iotDevices).length === 0) {
                sliderContainer.innerHTML = '<p style="color: #94a3b8; font-size: 13px; text-align: center; padding: 20px;">No IoT devices added yet</p>';
            }

            selectedCurves.clear();
            updateCurveListbox();
            updatePlot();
            
            // Hide sufficiency results if IoT devices are removed
            if (Object.keys(iotDevices).length === 0) {
                document.getElementById('sufficiencyResults').style.display = 'none';
            }
        }

        // Check sufficiency of PV devices for IoT devices
        function checkSufficiency() {
            const lowIllum = parseFloat(document.getElementById('lowIllumination').value);
            const highIllum = parseFloat(document.getElementById('highIllumination').value);

            if (isNaN(lowIllum) || isNaN(highIllum)) {
                alert('Please enter valid illumination range values');
                return;
            }

            if (lowIllum >= highIllum) {
                alert('Lowest illumination must be less than highest illumination');
                return;
            }

            if (Object.keys(iotDevices).length === 0) {
                alert('Please add at least one IoT device first');
                return;
            }

            if (Object.keys(pvData).length === 0) {
                alert('Please load at least one PV data file first');
                return;
            }

            const resultsContent = document.getElementById('sufficiencyContent');
            resultsContent.innerHTML = '';
            
            let hasResults = false;

            Object.entries(iotDevices).forEach(([iotName, device]) => {
                let bestCoverage = 0;
                let bestPV = null;
                const pvResults = [];

                Object.entries(pvData).forEach(([pvName, data]) => {
                    // Filter data within illumination range
                    const relevantData = data.filter(d => d[0] >= lowIllum && d[0] <= highIllum);
                    
                    if (relevantData.length === 0) return;

                    let countMet = 0;
                    let surplusSum = 0;
                    const lossMultiplier = 1 - (lossFactor / 100);

                    relevantData.forEach(([illum, eff]) => {
                        const pgd = illum * eff / 100 * lossMultiplier;
                        if (pgd >= device.pcd) {
                            countMet++;
                        }
                        surplusSum += (pgd - device.pcd);
                    });

                    const coverage = (countMet / relevantData.length) * 100;
                    const avgSurplus = surplusSum / relevantData.length;

                    pvResults.push({ pvName, coverage, avgSurplus });

                    if (coverage > bestCoverage) {
                        bestCoverage = coverage;
                        bestPV = pvName;
                    }
                });

                // Update slider border color
                const sliderDiv = document.getElementById(`slider-${iotName}`);
                if (sliderDiv) {
                    if (bestCoverage >= 90) {
                        sliderDiv.style.borderColor = '#10b981';
                    } else if (bestCoverage >= 50) {
                        sliderDiv.style.borderColor = '#f59e0b';
                    } else {
                        sliderDiv.style.borderColor = '#ef4444';
                    }
                }

                // Create results display
                if (pvResults.length > 0) {
                    hasResults = true;
                    const iotDiv = document.createElement('div');
                    iotDiv.style.marginBottom = '20px';
                    
                    let statusClass = 'poor';
                    let statusText = '‚ùå Poor';
                    let statusColor = '#ef4444';
                    
                    if (bestCoverage >= 90) {
                        statusClass = 'excellent';
                        statusText = '‚úÖ Excellent';
                        statusColor = '#10b981';
                    } else if (bestCoverage >= 50) {
                        statusClass = 'good';
                        statusText = '‚ö†Ô∏è Moderate';
                        statusColor = '#f59e0b';
                    }

                    iotDiv.innerHTML = `
                        <div class="sufficiency-item ${statusClass}">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <strong style="color: #60a5fa; font-size: 14px;">${iotName}</strong>
                                <span style="color: ${statusColor}; font-weight: 600;">${statusText}</span>
                            </div>
                            <div style="color: #94a3b8; font-size: 12px; margin-bottom: 8px;">
                                Required PCD: ${device.pcd.toFixed(2)} mW/cm¬≤ | Illumination: ${lowIllum}-${highIllum} mW/cm¬≤
                            </div>
                        </div>
                    `;

                    pvResults.sort((a, b) => b.coverage - a.coverage).forEach(result => {
                        let coverageClass = 'poor';
                        if (result.coverage >= 90) coverageClass = 'excellent';
                        else if (result.coverage >= 50) coverageClass = 'good';

                        const pvResult = document.createElement('div');
                        pvResult.style.marginLeft = '10px';
                        pvResult.style.marginTop = '10px';
                        pvResult.style.padding = '10px';
                        pvResult.style.backgroundColor = '#0f1923';
                        pvResult.style.borderRadius = '6px';
                        
                        pvResult.innerHTML = `
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span style="color: #cbd5e1;">${result.pvName}</span>
                                <span style="color: #60a5fa; font-weight: 600;">${result.coverage.toFixed(1)}% coverage</span>
                            </div>
                            <div class="coverage-bar">
                                <div class="coverage-fill ${coverageClass}" style="width: ${result.coverage}%;"></div>
                            </div>
                            <div style="font-size: 12px; color: #94a3b8;">
                                Avg. Surplus: ${result.avgSurplus >= 0 ? '+' : ''}${result.avgSurplus.toFixed(3)} mW/cm¬≤
                            </div>
                        `;
                        
                        iotDiv.appendChild(pvResult);
                    });

                    resultsContent.appendChild(iotDiv);
                }
            });

            if (hasResults) {
                document.getElementById('sufficiencyResults').style.display = 'block';
            } else {
                alert('No PV data found in the specified illumination range');
            }
        }

        // Update plot
        function updatePlot() {
            const datasets = [];
            const lossMultiplier = 1 - (lossFactor / 100);

            // Add PV data
            Object.entries(pvData).forEach(([name, data]) => {
                const x = data.map(d => d[0]);
                const y = data.map(d => (d[0] * d[1] / 100) * lossMultiplier);
                
                datasets.push({
                    label: name,
                    data: x.map((xi, i) => ({ x: xi, y: y[i] })),
                    borderColor: colors[name],
                    backgroundColor: colors[name],
                    borderWidth: 2.5,
                    pointRadius: 0,
                    tension: 0.1
                });
            });

            // Add IoT devices as horizontal lines
            Object.entries(iotDevices).forEach(([name, device]) => {
                const maxX = Math.max(...Object.values(pvData).flatMap(d => d.map(p => p[0])), 10);
                datasets.push({
                    label: `${name} (œÉ_PCD=${device.pcd.toFixed(2)} mW/cm¬≤)`,
                    data: [{ x: 0, y: device.pcd }, { x: maxX, y: device.pcd }],
                    borderColor: iotColors[name],
                    backgroundColor: iotColors[name],
                    borderWidth: 2.5,
                    borderDash: [5, 5],
                    pointRadius: 0
                });
            });

            // Add detailed balance limit
            if (document.getElementById('showDetailedBalance').checked) {
                datasets.push({
                    label: 'Detailed Balance Limit',
                    data: detailedBalanceData.x.map((x, i) => ({ x, y: detailedBalanceData.y[i] })),
                    borderColor: 'black',
                    backgroundColor: 'black',
                    borderWidth: 2.5,
                    borderDash: [10, 5],
                    pointRadius: 0
                });
            }

            // Update chart
            chart.data.datasets = datasets;

            // Update y-axis scale
            if (document.getElementById('logScale').checked) {
                chart.options.scales.y.type = 'logarithmic';
            } else {
                chart.options.scales.y.type = 'linear';
            }

            // Add illumination range
            const lowIllum = parseFloat(document.getElementById('lowIllumination').value);
            const highIllum = parseFloat(document.getElementById('highIllumination').value);
            
            if (!isNaN(lowIllum) && !isNaN(highIllum) && lowIllum < highIllum) {
                chart.options.plugins.annotation = {
                    annotations: {
                        box1: {
                            type: 'box',
                            xMin: lowIllum,
                            xMax: highIllum,
                            backgroundColor: 'rgba(255, 255, 0, 0.3)',
                            borderWidth: 0,
                            label: {
                                content: 'Expected Illumination Range',
                                enabled: true
                            }
                        }
                    }
                };
            }

            chart.update();
        }

        // Export graph
        function exportGraph() {
            const link = document.createElement('a');
            link.download = 'pv_iot_graph.png';
            link.href = chart.toBase64Image();
            link.click();
        }

        // Export data
        function exportData() {
            let text = '';

            // PV devices
            Object.entries(pvData).forEach(([name, data]) => {
                text += `Data for ${name} (PV Device):\n`;
                data.forEach(([ip, eff]) => {
                    const pgd = ip * eff / 100;
                    text += `${ip.toFixed(2)}\t${pgd.toFixed(2)}\n`;
                });
                text += '\n';
            });

            // IoT devices
            Object.entries(iotDevices).forEach(([name, device]) => {
                text += `Data for ${name} (IoT Device):\n`;
                text += `Power Consumption Density (mW/cm¬≤): ${device.pcd.toFixed(2)}\n\n`;
            });

            // Detailed balance
            if (document.getElementById('showDetailedBalance').checked) {
                text += 'Detailed Balance Limit:\n';
                detailedBalanceData.x.forEach((x, i) => {
                    text += `${x.toFixed(2)}\t${detailedBalanceData.y[i].toFixed(2)}\n`;
                });
            }

            const blob = new Blob([text], { type: 'text/plain' });
            const link = document.createElement('a');
            link.download = 'pv_iot_data.txt';
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        // Generate PDF report
        function generateReport() {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF();

            // Title
            pdf.setFontSize(16);
            pdf.text('Indoor PV and IoT Device Matcher Report', 105, 10, { align: 'center' });

            // Add chart image
            const imgData = chart.toBase64Image();
            pdf.addImage(imgData, 'PNG', 10, 20, 190, 100);

            // Add data
            let yPos = 130;
            pdf.setFontSize(14);
            pdf.text('PV System Data', 10, yPos);
            yPos += 10;

            pdf.setFontSize(10);
            Object.entries(pvData).forEach(([name, data]) => {
                if (yPos > 270) {
                    pdf.addPage();
                    yPos = 20;
                }
                pdf.text(`Data for ${name}`, 10, yPos);
                yPos += 7;
            });

            yPos += 5;
            pdf.setFontSize(14);
            pdf.text('IoT Devices', 10, yPos);
            yPos += 10;

            pdf.setFontSize(10);
            Object.entries(iotDevices).forEach(([name, device]) => {
                if (yPos > 250) {
                    pdf.addPage();
                    yPos = 20;
                }
                pdf.text(`${name}:`, 10, yPos);
                pdf.text(`  Peak Power: ${(originalPCD[name] * device.scaleFactor).toFixed(2)} mW`, 10, yPos + 5);
                pdf.text(`  Surface Area: ${device.surfaceArea.toFixed(2)} cm¬≤`, 10, yPos + 10);
                pdf.text(`  Power Consumption Density: ${device.pcd.toFixed(2)} mW/cm¬≤`, 10, yPos + 15);
                pdf.text(`  Scaling Factor: ${device.scaleFactor.toFixed(2)}`, 10, yPos + 20);
                yPos += 30;
            });

            // System parameters
            if (yPos > 260) {
                pdf.addPage();
                yPos = 20;
            }
            pdf.setFontSize(14);
            pdf.text('System Parameters', 10, yPos);
            yPos += 10;
            pdf.setFontSize(10);
            pdf.text(`Conversion Loss Factor: ${lossFactor.toFixed(2)}%`, 10, yPos);

            // Watermark
            pdf.setFontSize(8);
            pdf.setTextColor(128);
            pdf.text('Generated by Indoor PV and IoT Device Matcher V2.5 (HTML)', 200, 290, { align: 'right' });

            pdf.save('pv_iot_report.pdf');
        }

        // Initialize
        initChart();
    </script>
</body>
</html>
